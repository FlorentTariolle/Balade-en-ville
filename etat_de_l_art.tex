\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{float}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{xcolor}

\title{État de l'art : Optimisation de livraison dans un réseau urbain}
\author{Florent Tariolle et Amine Tauil}
\date{22 octobre 2025}

\begin{document}

\maketitle

\section{Introduction}

Ce document présente l'état de l'art concernant le problème d'optimisation de livraison dans un réseau urbain modélisé par un graphe. Le problème se décompose en deux étapes principales : le calcul des plus courts chemins entre tous les points d'intérêt, puis la résolution du problème du voyageur de commerce (TSP) pour déterminer l'itinéraire optimal de livraison.

\section{Problématique}

Le problème consiste à optimiser les livraisons depuis un dépôt vers plusieurs adresses dans une ville. La ville est modélisée par un graphe non orienté $G_1 = (V_1, E_1)$ où :
\begin{itemize}
    \item $V_1$ représente les intersections, adresses de livraison et arrêts de métro
    \item $E_1$ représente les tronçons de route et les connexions du métro
\end{itemize}

L'objectif est de trouver un chemin optimal qui part du dépôt, visite toutes les adresses de livraison, et retourne au dépôt.

\section{Approche en deux graphes}

\subsection{Premier graphe : Calcul des distances minimales}

Le premier problème formel est le \textbf{All-Pairs Shortest Path (APSP)} : calculer la distance minimale entre chaque paire de sommets dans le graphe $G_1$.

\subsubsection{État de l'art pour APSP}

Plusieurs algorithmes existent pour résoudre le problème APSP :
\begin{itemize}
    \item \textbf{Algorithme de Floyd-Warshall} : complexité $O(V^3)$, adapté aux graphes denses
    \item \textbf{Repeated BFS} : complexité $O(V \times (V + E))$ pour les graphes non pondérés
    \item \textbf{Algorithme de Dijkstra répété} : complexité $O(V \times (E + V \log V))$ pour les graphes pondérés
    \item \textbf{Algorithmes avancés} : Seidel \cite{dorhalperinzwick}, techniques de multiplication de matrices rapides
\end{itemize}

\subsubsection{Choix de l'algorithme : Repeated BFS}

Nous avons choisi l'algorithme \textbf{Repeated BFS} (Breadth-First Search répété) pour les raisons suivantes :

\begin{enumerate}
    \item \textbf{Simplicité d'implémentation} : Le BFS est un algorithme fondamental et facile à comprendre
    \item \textbf{Efficacité pour graphes non pondérés} : Dans notre cas, chaque tronçon de route a une distance unitaire (1), ce qui rend le BFS optimal
    \item \textbf{Complexité adaptée} : Pour un graphe avec $V$ sommets et $E$ arêtes, la complexité est $O(V \times (V + E))$, ce qui est efficace pour notre taille de graphe (22 sommets)
    \item \textbf{Exactitude garantie} : Le BFS garantit de trouver le plus court chemin dans un graphe non pondéré
\end{enumerate}

\subsubsection{Pseudocode de Repeated BFS}

\begin{algorithm}[H]
\caption{Repeated BFS pour APSP}
\begin{algorithmic}[1]
\STATE Initialiser une matrice $V \times V$ de distances avec $\infty$, diagonale à $0$
\FOR{chaque sommet source $s$ dans le graphe}
    \STATE Initialiser une file avec $s$ (distance $0$), ensemble visité
    \WHILE{file non vide}
        \STATE Défiler $u$
        \FOR{chaque voisin $v$ de $u$}
            \IF{$v$ non visité OU distance peut être mise à jour}
                \STATE $dist[s][v] = dist[s][u] + 1$
                \STATE Enfiler $v$, marquer comme visité
            \ENDIF
        \ENDFOR
    \ENDWHILE
\ENDFOR
\end{algorithmic}
\end{algorithm}

\subsection{Deuxième graphe : Graphe complet valué}

À partir de la matrice des distances minimales, nous construisons un deuxième graphe $G_2 = (V_2, E_2)$ où :
\begin{itemize}
    \item $V_2 = V_1$ (mêmes sommets que le graphe original)
    \item $E_2$ contient toutes les paires de sommets, chaque arête $(u,v)$ étant valuée par la distance minimale entre $u$ et $v$ dans $G_1$
\end{itemize}

Ce graphe complet valué représente les distances optimales entre tous les points d'intérêt.

\subsection{Problème du voyageur de commerce (TSP)}

Sur le graphe complet $G_2$, nous devons résoudre le TSP : trouver un cycle hamiltonien de coût minimal qui visite toutes les adresses de livraison en partant et revenant au dépôt.

\subsubsection{État de l'art pour TSP}

Le TSP est un problème NP-complet. Plusieurs approches existent :

\begin{itemize}
    \item \textbf{Algorithmes exacts} :
    \begin{itemize}
        \item \textbf{Held-Karp (programmation dynamique)} : complexité $O(2^n \times n^2)$ en temps, $O(2^n \times n)$ en espace
        \item \textbf{Branch and Bound} : complexité exponentielle dans le pire cas
        \item \textbf{Algorithmes de concorde} : optimisés pour des instances spécifiques
    \end{itemize}
    \item \textbf{Algorithmes approchés} :
    \begin{itemize}
        \item \textbf{Heuristiques constructives} : Nearest Neighbor, Insertion, etc.
        \item \textbf{Amélioration locale} : 2-opt, 3-opt, Lin-Kernighan
        \item \textbf{Métaheuristiques} : Recuit simulé, Algorithmes génétiques, Colonies de fourmis
    \end{itemize}
\end{itemize}

\subsubsection{Choix de l'algorithme : Held-Karp}

Nous avons choisi l'algorithme de \textbf{Held-Karp} (aussi appelé algorithme de Bellman-Held-Karp) pour les raisons suivantes :

\begin{enumerate}
    \item \textbf{Solution exacte} : Contrairement aux heuristiques, Held-Karp garantit la solution optimale
    \item \textbf{Taille du problème gérable} : Avec 5 villes à visiter (dépôt + 4 adresses), la complexité $O(2^5 \times 5^2) = O(800)$ est instantanée
    \item \textbf{Fiabilité} : Pas de dépendance aux heuristiques qui peuvent donner des résultats sous-optimaux
    \item \textbf{Standard de l'industrie} : Held-Karp est l'algorithme standard pour les petites instances de TSP
\end{enumerate}

\subsubsection{Principe de Held-Karp}

Held-Karp utilise la programmation dynamique avec des masques binaires :
\begin{itemize}
    \item $dp[mask][j]$ = coût minimal pour visiter toutes les villes dans $mask$ et finir à la ville $j$
    \item Récurrence : $dp[mask][j] = \min_{k \in mask \setminus \{j\}} (dp[mask \setminus \{j\}][k] + dist(k,j))$
    \item Cas de base : $dp[\{s\}][s] = 0$ où $s$ est le dépôt
\end{itemize}

La complexité est $O(2^n \times n^2)$ où $n$ est le nombre de villes à visiter.

\section{Justification des choix algorithmiques}

\subsection{Pourquoi Repeated BFS plutôt que Floyd-Warshall ?}

\begin{itemize}
    \item Notre graphe est \textbf{non pondéré} : toutes les arêtes ont un poids de 1
    \item Floyd-Warshall est conçu pour les graphes pondérés et nécessite $O(V^3)$ opérations
    \item BFS est spécialement optimisé pour les graphes non pondérés avec complexité $O(V + E)$ par source
    \item Pour notre graphe de 22 sommets, Repeated BFS est plus efficace et plus simple à implémenter
\end{itemize}

\subsection{Pourquoi Held-Karp plutôt qu'une heuristique ?}

\begin{itemize}
    \item Le nombre de villes à visiter est \textbf{petit} (5 villes) : la complexité exponentielle est gérable
    \item Nous voulons la \textbf{solution optimale}, pas une approximation
    \item Les heuristiques peuvent donner des solutions jusqu'à 25\% plus longues que l'optimum
    \item Held-Karp garantit la solution exacte avec un temps de calcul négligeable pour 5 villes
\end{itemize}

\subsection{Pourquoi créer un graphe complet intermédiaire ?}

\begin{itemize}
    \item Le TSP nécessite les distances entre \textbf{toutes} les paires de villes
    \item Le graphe original contient des chemins indirects : créer le graphe complet pré-calcule tous les plus courts chemins
    \item Cela permet de résoudre le TSP sur un graphe complet, ce qui est l'hypothèse standard de Held-Karp
    \item La transformation est en $O(V^2)$ une fois que la matrice APSP est calculée
\end{itemize}

\section{Complexité globale}

\begin{itemize}
    \item \textbf{Étape 1 - APSP} : $O(V \times (V + E)) = O(22 \times (22 + E))$ où $E$ est le nombre d'arêtes
    \item \textbf{Étape 2 - Création du graphe complet} : $O(V^2)$
    \item \textbf{Étape 3 - TSP avec Held-Karp} : $O(2^n \times n^2)$ où $n$ est le nombre de villes à visiter (5)
    \item \textbf{Complexité totale} : Dominée par l'APSP, donc $O(V \times (V + E))$
\end{itemize}

Pour notre instance avec 22 sommets et environ 29 arêtes (non orientées), la complexité est très raisonnable et le calcul est instantané.

\section{Adaptation : Gestion de la panne du métro}

\subsection{Question théorique : Détection de l'utilisation du métro}

Pour savoir si le trajet généré emprunte le métro ou non, il faut adapter la modélisation de la manière suivante :

\begin{enumerate}
    \item \textbf{Marquer les arêtes du métro} : Attribuer un attribut ou un type différent aux arêtes correspondant aux connexions du métro (par exemple, ajouter un champ \texttt{type} aux arêtes : \texttt{ROUTE} ou \texttt{METRO}).
    
    \item \textbf{Tracer le chemin dans le graphe original} : Après avoir résolu le TSP sur le graphe complet valué, reconstruire le chemin réel dans le graphe original $G_1$. Pour chaque paire de villes consécutives dans la solution du TSP, trouver le plus court chemin dans $G_1$ qui les relie (utiliser un algorithme de reconstruction de chemin ou re-BFS).
    
    \item \textbf{Vérifier si le chemin passe par des arrêts de métro} : Pour chaque segment du chemin reconstruit, vérifier s'il contient des arrêts de métro. Si le chemin entre deux adresses passe par \texttt{arret\_metro\_rouge}, \texttt{arret\_metro\_jaune} ou \texttt{arret\_metro\_vert}, alors le métro est utilisé.
    
    \item \textbf{Afficher l'information} : Pour chaque étape du trajet, indiquer "Aller de X à Y via [MÉTRO / ROUTE]" et calculer le pourcentage du trajet effectué en métro.
\end{enumerate}

\textbf{En résumé} : Il faut enrichir la modélisation pour distinguer les arêtes de métro, puis reconstruire le chemin dans le graphe original pour détecter quels segments utilisent effectivement le métro.

\subsection{Impact de la panne du métro sur l'algorithme}

\subsubsection{Implications}

La panne du métro implique les modifications suivantes :

\begin{itemize}
    \item \textbf{Modification du graphe} : Supprimer les arêtes reliant les arrêts de métro entre eux (ligne de métro). Les arrêts de métro restent dans le graphe (accessibles par la route), mais ne sont plus reliés directement entre eux.
    
    \item \textbf{Impact sur le calcul des distances} : Le BFS répété recalcule automatiquement les distances sans les connexions du métro. Certaines distances entre arrêts de métro augmentent (passent de 1 à plusieurs tronçons). La matrice APSP change, notamment pour les paires impliquant des arrêts de métro.
    
    \item \textbf{Impact sur le graphe complet valué} : Les nouvelles distances sont reflétées dans le graphe complet. Le coût du trajet optimal peut augmenter et l'ordre des visites peut changer.
    
    \item \textbf{Impact sur Held-Karp} : L'algorithme Held-Karp fonctionne de la même manière, mais avec des distances différentes. La solution optimale peut changer en termes de coût et d'ordre des visites, mais reste exacte.
\end{itemize}

\subsubsection{Modifications apportées au code}

Pour gérer la panne du métro, nous avons modifié le code de la manière suivante :

\begin{enumerate}
    \item \textbf{Ajout d'un paramètre à \texttt{creerGrapheVille}} : 
    \begin{itemize}
        \item Ajout d'un paramètre \texttt{boolean metroActif} pour contrôler si le métro est fonctionnel
        \item Les arêtes du métro ne sont ajoutées que si \texttt{metroActif = true}
        \item Les arrêts de métro restent accessibles uniquement par la route si le métro est en panne
    \end{itemize}
    
    \item \textbf{Création d'une méthode \texttt{resoudreTSP}} : Extraction de la logique de résolution du TSP dans une méthode réutilisable pour éviter la duplication de code.
    
    \item \textbf{Modification du \texttt{main}} : Le programme résout maintenant le problème deux fois : une fois avec le métro fonctionnel et une fois sans le métro, permettant la comparaison des résultats.
\end{enumerate}

\subsection{Résultats comparatifs}

\subsubsection{Avec métro fonctionnel}

\begin{itemize}
    \item \textbf{Coût minimal} : 18
    \item \textbf{Chemin optimal} : depot\_rue\_bleu → 3\_rue\_marron → 22\_rue\_vert → 8\_rue\_mauve → 10\_rue\_rouge → depot\_rue\_bleu
\end{itemize}

\subsubsection{Sans métro (panne)}

\begin{itemize}
    \item \textbf{Coût minimal} : 22
    \item \textbf{Chemin optimal} : depot\_rue\_bleu → 3\_rue\_marron → 22\_rue\_vert → 10\_rue\_rouge → 8\_rue\_mauve → depot\_rue\_bleu
\end{itemize}

\subsubsection{Analyse}

\begin{itemize}
    \item \textbf{Impact sur le coût} : Le coût augmente de 18 à 22 (+22\%), car sans le métro, certaines connexions directes entre arrêts de métro ne sont plus disponibles.
    
    \item \textbf{Impact sur l'ordre} : L'ordre des visites change : avec le métro, on visite 8\_rue\_mauve avant 10\_rue\_rouge, mais sans métro, l'ordre inverse devient optimal.
    
    \item \textbf{Robustesse} : Le graphe reste connexe car tous les arrêts de métro restent accessibles par la route, mais les distances augmentent.
\end{itemize}

\section{Conclusion}

L'approche en deux graphes avec Repeated BFS et Held-Karp est adaptée à notre problème car :
\begin{enumerate}
    \item Elle exploite la structure du graphe (non pondéré) pour utiliser BFS de manière optimale
    \item Elle garantit la solution optimale du TSP grâce à Held-Karp
    \item Elle reste efficace pour la taille de notre instance (22 sommets, 5 villes à visiter)
    \item Elle est simple à implémenter et à maintenir
    \item Elle s'adapte facilement aux changements de contraintes (comme la panne du métro)
\end{enumerate}

Cette combinaison d'algorithmes classiques et éprouvés constitue une solution robuste et exacte pour le problème d'optimisation de livraison.

\begin{thebibliography}{9}
\bibitem{dorhalperinzwick}
Seidel, R. (1992). On the all-pairs-shortest-path problem. \textit{Proceedings of the 24th Annual ACM Symposium on Theory of Computing}, pp. 745-749.

\bibitem{heldkarp}
Held, M., \& Karp, R. M. (1962). A dynamic programming approach to sequencing problems. \textit{Journal of the Society for Industrial and Applied Mathematics}, 10(1), 196-210.

\bibitem{bfs}
Cormen, T. H., Leiserson, C. E., Rivest, R. L., \& Stein, C. (2009). \textit{Introduction to Algorithms} (3rd ed.). MIT Press. Chapter 22: Elementary Graph Algorithms.

\bibitem{tsp}
Applegate, D. L., Bixby, R. E., Chvátal, V., \& Cook, W. J. (2007). \textit{The Traveling Salesman Problem: A Computational Study}. Princeton University Press.
\end{thebibliography}

\end{document}

